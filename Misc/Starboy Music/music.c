#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  touchSensL,     sensorTouch)
#pragma config(Sensor, dgtl2,  touchSensR,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           driveLeftBack, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           armLTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           armLBot,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armRTop,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armRBot,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveRightBack, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          knock,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)


//GLOBAL VARIABLES
float powerExpanderBatteryV;
//Control variables
int dlC, drC, armC, knockC, forwardsC, backwardsC, touchSensLC, touchSensRC, musicCtrl = 1;
float armMultiplier, dMult = 1;

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify
#include "music.h"
#include "Starstruck.h"

//CONSTANTS
#define LOOPSPEED 50 //Time between user control loops in milliseconds - time alloted to other tasks while usercontrol is idle
#define DEADZONE 20 //Deadzone for joystick control


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.

	bStopTasksBetweenModes = true;
}

task autonomous()
{
	motor[knock] = 100;
	wait1Msec(2500);
	motor[knock] = 0;
	nMotorEncoder[driveLeftBack] = 0;
	nMotorEncoder[driveRightBack] = 0;
	//While both of the encoders are less than the specified amount
}

task nonMusic() {
	nSchedulePriority = 10;
	//Math variables
	int lastArmC, currArmC;
	while(true){
		dlC = vexRT[Ch3];
		drC = vexRT[Ch2];
		armC = vexRT[Ch2Xmtr2];
		knockC = vexRT[Ch3Xmtr2];
		forwardsC = vexRT[Btn7U];
		backwardsC = vexRT[Btn7D];
		touchSensRC = SensorValue[touchSensL];
		touchSensLC = SensorValue[touchSensR];
		musicCtrl = vexRT[Btn7UXmtr2];
		if(forwardsC == 1) {
			dMult = 1;
			} else if(backwardsC == 1) {
			dMult = -1;
		}

		if(abs(dlC) > DEADZONE)	{
			motor[driveLeftBack] = dlC * dMult;
			motor[driveLeftFront] = dlC * dMult;
		}
		else {
			motor[driveLeftBack] = 0;
			motor[driveLeftFront] = 0;
		}
		if(abs(drC) > DEADZONE)	{
			motor[driveRightBack] = drC * dMult;
			motor[driveRightFront] = drC * dMult;
		}
		else {
			motor[driveRightBack] = 0;
			motor[driveRightFront] = 0;
		}

		lastArmC = currArmC;
		currArmC = armC;

		if((touchSensLC == 1 || touchSensRC == 1) & armC > 0) {
			motor[armLTop] = 0;
			motor[armLBot] = 0;
			motor[armRTop] = 0;
			motor[armRBot] = 0;
			} else if(abs(armC) > DEADZONE)	{
			motor[armLTop] = armC;
			motor[armLBot] = armC;
			motor[armRTop] = armC;
			motor[armRBot] = armC;
			} else {
			motor[armLTop] = 0;
			motor[armLBot] = 0;
			motor[armRTop] = 0;
			motor[armRBot] = 0;
		}


		if(abs(knockC) > DEADZONE)	{
			motor[knock] = knockC;
		}
		else {
			motor[knock] = 0;
		}
		//Displays Battery Levels to VEX Remote Screen
		powerExpanderBatteryV = SensorValue[in1]/.28;
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0,0);
		displayNextLCDString("C Bat:");
		displayNextLCDNumber(nAvgBatteryLevel);
		displayLCDPos(1,0);
		displayNextLCDString("P.E Bat:");
		displayNextLCDNumber(powerExpanderBatteryV);

		wait1Msec(LOOPSPEED);
	}

}

task music()
{
	startTask(nonMusic);
	nSchedulePriority = 8;
	unsigned int beat = 0;
	while(true) {
		if(musicCtrl == 1) {

			if(beat <= 70) {
				playImmediateTone(intro[beat][0],(intro[beat][1]-3));

				//Defer to other tasks
				wait1Msec(intro[beat][1] * 10);
				} else if(beat <= 227) {
				playImmediateTone(beforeRepeat[beat-71][0], (beforeRepeat[beat-71][1]-3));
				wait1Msec(beforeRepeat[beat-71][1] * 10);
				} else if(beat <= 316) {
				playImmediateTone(chorus1[beat-228][0], (chorus1[beat-228][1]-3));
				wait1Msec(chorus1[beat-228][1] * 10);
				} else if(beat <= 474) {
				if(beat == 317) {
					playImmediateTone(0, 64.171);
					wait1Msec(641.71);
				}
				playImmediateTone(beforeRepeat[beat-317][0], (beforeRepeat[beat-317][1]-3));
				wait1Msec(beforeRepeat[beat-317][1] * 10);
				} else if(beat <= 562) {
				playImmediateTone(chorus2[beat-475][0], (chorus2[beat-475][1]-3));
				wait1Msec(chorus2[beat-475][1] * 10);
				} else if(beat <= 719) {
				if(beat == 563) {
					playImmediateTone(0, 64.171);
					wait1Msec(641.71);
				}
				playImmediateTone(beforeRepeat[beat-563][0], (beforeRepeat[beat-563][1]-3));
				wait1Msec(beforeRepeat[beat-563][1] * 10);
			}
			//Advance beat,


			//Beat advancing and repeat
			beat++;
			if(beat > 719) {
				beat = 0;
			}
		}	else {wait1Msec(1000);}
	}
}

task usercontrol()
{
	startTask(music);
}
