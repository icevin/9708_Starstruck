
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#ifndef MOTORC
#define MOTORC

#define MOTOR_MAX_VALUE 127
#define MOTOR_MIN_VALUE -127
#define slew 5

/*
int motorReq[10];
int motorCur[10];

int forceSetMotor(int port, int power);
int reqMotor(int port, int power);
int setSlew(int port, int slew);

task motorSlewControl() {
	while(true) {
		for(int x = 0; x<10; x++) {
			if(motorReq[x] == motorCur[x]) {
				continue;
			}

			if(motorCur[x] < motorReq[x]) {
				motorCur[x] += slew;
			} else if(motorCur[x] > motorReq[x]) {
				motorCur[x] -= slew;
			}

			forceSetMotor(x, motorCur[x]);
			wait1Msec(LOOPSPEED+LOOPSPEED);
		}
	}
}

int forceSetMotor(int port, int power) {
	motorCur[port] = power;
	if(abs(power) < MOTOR_MAX_VALUE) {
		motor[port+1] = power;
	}
}

int reqMotor(int port, int power, speed) {
	motorReq[port] = power;
} */

/*
task pidController()
{
	startTask(music, 4);
	float pidErrorL;
	float pidLastErrorL;
	float pidIntegralL;
	float pidDerivativeL;

	float pidErrorR;
	float pidLastErrorR;
	float pidIntegralR;
	float pidDerivativeR;

	pidLastErrorL = 0;
	pidIntegralL = 0;

	pidLastErrorR = 0;
	pidIntegralR = 0;

	while (true)
	{
		if(flyStartup == 1 && (flyVelocityR>requestedShooterSpeed))
			flyStartup = 0;
		else if(flyStartup==0)
			pidSelect();

		pidErrorL = requestedShooterSpeed-flyVelocityL;

		if(pid_Ki!=0)
		{
			if(fabs(pidErrorL) < PID_INTEGRAL_LIMIT)
				pidIntegralL = pidIntegralL + pidErrorL;
			else
				pidIntegralL = 0;
		}
		else
			pidIntegralL = 0;
		if(pidErrorL !=0)
		{
			pidDerivativeL = pidErrorL - pidLastErrorL;
			pidLastErrorL = pidErrorL;
		}
		else
		{
			pidDerivativeL = 0;
		}
		if(pidErrorL < 4.0)
		{
			pidIntegralL = 0;
		}
		pidDriveL+= (pid_Kp*pidErrorL) + (pid_Ki*pidIntegralL) + (pid_Kd * pidDerivativeL);

		if(pidDriveL > PID_DRIVE_MAX)
			pidDriveL = PID_DRIVE_MAX;
		if(pidDriveL < PID_DRIVE_MIN)
			pidDriveL = PID_DRIVE_MIN;

} */





























#endif
