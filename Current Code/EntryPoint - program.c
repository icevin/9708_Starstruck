#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potL,           sensorPotentiometer)
#pragma config(Sensor, in2,    potR,           sensorPotentiometer)
#pragma config(Sensor, in3,    lineL,          sensorLineFollower)
#pragma config(Sensor, in4,    lineR,          sensorLineFollower)
#pragma config(Sensor, dgtl2,  armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  clawUltrasonic, sensorSONAR_inch)
#pragma config(Sensor, dgtl11, armEncoderL,    sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           clawL,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           dLeftF,        tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port3,           dLeftB,        tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           armL1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armL2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armR1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armR2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           dRightF,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           dRightB,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          clawR,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)


/* NOTES
Potentiometer key:
Closed: ~3900
180 Degrees: ~2660
45 degrees (facing towards stars but not closed): ~1700
Fully closed: ~1000, 1100
*/


#define LOOPSPEED 50 //Time between user control loops in milliseconds - time alloted to other tasks while usercontrol is idle
#define DEADZONE 30 //Deadzone for joystick control
#define m_clawL 1
#define m_dLeftF 2
#define m_dLeftB 3
#define m_armL1 4
#define m_armL2 5
#define m_armR1 6
#define m_armR2 7
#define m_dRightF 8
#define m_dRightB 9
#define m_clawR 10

//ENCODER TICKS PER REVOLUTION
#define TURBOM          261.333
#define SPEEDM          392
#define TORQUM          627.2
#define QUAD          360.0

#define joy_left_vertical "Ch3Xmtr2"
#define joy_left_horizontal "Ch4Xmtr2"
#define joy_right_vertical "Ch2Xmtr2"
#define joy_right_horizontal "Ch1Xmtr2"

#define ROTATION_REDUCTION 0.75

#define PID_MAX 120
#define PID_MIN -120
#define PID_INTEGRAL_LIMIT 40
#define PID_POLL_RATE 100 //Milliseconds between PID controller updates

#define CLAW_FULL_CLOSED 1100
#define CLAW_HALF_CLOSED 2673
#define CLAW_180 3858
#define CLAW-STOWED 3800

//GLOBAL VARIABLES
float powerExpanderBatteryV;
//Control variables
int armC, armUp, armDown, openClaw, closeClaw;
int armMotors;
int clawRequest;



#include "Vex_Competition_Includes.c"
#include "StarstruckIncludes.h"
#include "motor.c"
#include "auton.h"





void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.

	bStopTasksBetweenModes = true;
}

task autonomous()
{
	motor[dLeftF] = -90;	//START MOVING BACKWARDS
	motor[dRightF] = -90;
	motor[dLeftB] = -90;
	motor[dRightB] = -90;
	wait1Msec(1500);
	setDriveMotors(0, 0, 0);
	motor[clawL] = -100;
	motor[clawR] = -100;
	wait1Msec(1500);
	motor[clawL] = 0;
	motor[clawR] = 0;
	setArm(-30);
	wait1Msec(500);
	setArm(0);
	setDriveMotors(120, 0, 0);
	wait1Msec(1700);
	setDriveMotors(0,0,0);
	motor[clawL] = 110;
	motor[clawR] = 110;
	wait1Msec(1500);
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[clawL] = 80;
	motor[clawR] = 80;
	/*	waitUntilDetectChange();
	motor[clawL] = 50;
	motor[clawR] = 50;
	wait1Msec(1000);
	motor[clawL] = 0;
	motor[clawR] = 0;
	setArm(0);*/
	//setDriveMotors(-90, 0, 0);
	//wait1Msec(5000);
	motor[dLeftF] = -90;	//START MOVING BACKWARDS
	motor[dRightF] = -90;
	motor[dLeftB] = -90;
	motor[dRightB] = -90;

	wait1Msec(2000);			//WAIT 800MS
	motor[armL1] = 120;		//START DUMPING (still moving backwards)
	motor[armL2] = 120;
	motor[armR1] = 120;
	motor[armR2] = 120;
	//while (SensorValue(armEncoder) > -500)
	//{
	//	wait1Msec(10);		//WAIT UNTIL AT PEAK OF DUMP
	//}
	//	motor[clawL] = -90;	//START OPENING CLAW
	//	motor[clawR] = -90;
	//while (abs(SensorValue(potL) - CLAW_FULL_CLOSED) < 500)
	//{
	//	wait1Msec(10);			//WAIT UNTIL OPEN
	//}
	wait1Msec(1200);
	motor[clawL] = -90;	//START OPENING CLAW
	motor[clawR] = -90;
	wait1Msec(200);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	setDriveMotors(0, 0, 0);
	//cycle();
	setArm(-90);
	motor[clawL] = -90;
	motor[clawR] = -90;
	wait1Msec(1250);
	setArm(0);



	setDriveMotors(120, 0, 0);
	wait1Msec(2000);
	setDriveMotors(0,0,0);
	motor[clawL] = 90;
	motor[clawR] = 90;
	wait1Msec(2000);
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[clawL] = 80;
	motor[clawR] = 80;



	motor[dLeftF] = -90;	//START MOVING BACKWARDS
	motor[dRightF] = -90;
	motor[dLeftB] = -90;
	motor[dRightB] = -90;

	wait1Msec(2000);			//WAIT 800MS
	motor[armL1] = 120;		//START DUMPING (still moving backwards)
	motor[armL2] = 120;
	motor[armR1] = 120;
	motor[armR2] = 120;




	wait1Msec(1000);
	motor[clawL] = -90;	//START OPENING CLAW
	motor[clawR] = -90;
	wait1Msec(200);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	setDriveMotors(0, 0, 0);

		setArm(-90);
	motor[clawL] = -70;
	motor[clawR] = -70;
	wait1Msec(1250);
	setArm(0);
	setDriveMotors(120, 0, 0);
	wait1Msec(2000);
	setDriveMotors(0,0,0);
	motor[clawL] = 100;
	motor[clawR] = 100;
	wait1Msec(2000);
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[clawL] = 50;
	motor[clawR] = 50;



	motor[dLeftF] = -90;	//START MOVING BACKWARDS
	motor[dRightF] = -90;
	motor[dLeftB] = -90;
	motor[dRightB] = -90;

	wait1Msec(2000);			//WAIT 800MS
	motor[armL1] = 120;		//START DUMPING (still moving backwards)
	motor[armL2] = 120;
	motor[armR1] = 120;
	motor[armR2] = 120;



	wait1Msec(1000);
	motor[clawL] = -90;	//START OPENING CLAW
	motor[clawR] = -90;
	wait1Msec(200);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	setDriveMotors(0, 0, 0);

			setArm(-90);
	motor[clawL] = -70;
	motor[clawR] = -70;
	wait1Msec(1250);
	setArm(0);
	setDriveMotors(120, 0, 0);
	wait1Msec(2000);
		setDriveMotors(0,0,0);
	motor[clawL] = 100;
	motor[clawR] = 100;
	wait1Msec(1500);
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[clawL] = 50;
	motor[clawR] = 50;



	motor[dLeftF] = -90;	//START MOVING BACKWARDS
	motor[dRightF] = -90;
	motor[dLeftB] = -90;
	motor[dRightB] = -90;

	wait1Msec(2000);			//WAIT 800MS
	motor[armL1] = 120;		//START DUMPING (still moving backwards)
	motor[armL2] = 120;
	motor[armR1] = 120;
	motor[armR2] = 120;



	wait1Msec(1000);
	motor[clawL] = -90;	//START OPENING CLAW
	motor[clawR] = -90;
	wait1Msec(200);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	setDriveMotors(0, 0, 0);

	setArm(-90);
	motor[clawL] = -90;
	motor[clawR] = -90;
	wait1Msec(1250);
	setArm(0);
	setDriveMotors(90, 0, 0);
	wait1Msec(1500);
	setDriveMotors(0, -90, 0);
	wait1Msec(1000);
	setDriveMotors(100, 0, 0);
	motor[clawL] = 90;
	motor[clawR] = 90;
	wait1Msec(1000);
	setDriveMotors(0, 90, 0);
	wait1Msec(1000);


	setDriveMotors(-90, 0, 0);
	wait1Msec(1500);
	setArm(120);
	wait1Msec(1000);
	motor[clawL] = -90;	//START OPENING CLAW
	motor[clawR] = -90;
	wait1Msec(200);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	setDriveMotors(0, 0, 0);
}

int forwardVector, horizontalVector, rotationVector;
task control() {
	nSchedulePriority = 10;

	//Math variables
	int sign,signtemp, status, initEncoderL, encoderLChange, mReqLF, mReqRF, mReqLB, mReqRB, clawValue, clawClosed, rotationConstant = 0.5;

	initEncoderL=SensorValue(armEncoderL);
	encoderLChange=initEncoderL-330;
	status=encoderLChange-SensorValue(armEncoderL);
	if (status>=0)
		sign=1;
	else
		sign=-1;

	while(true){

		armC = vexRT[Ch2Xmtr2];
		openClaw = vexRT[Btn6UXmtr2] * 120;
		closeClaw = vexRT[Btn6DXmtr2] * -120;


		armUp = vexRT[Btn5UXmtr2];
		armDown = vexRT[Btn5DXmtr2];


		if(abs(SensorValue(potL) - CLAW_FULL_CLOSED) < 500)
			rotationConstant = 1;
		else
			rotationConstant = 2;


		forwardVector = vexRT[Ch3Xmtr2];
		horizontalVector = vexRT[Ch4Xmtr2];
		rotationVector = vexRT[Ch1Xmtr2]/rotationConstant;// * rotationConstant;


		//	if(abs(SensorValue(potL) - CLAW_FULL_CLOSED) < 500)
		//		rotationVector*=0.9;
		//	else
		///		rotationVector*=0.5;
		if (abs(horizontalVector)<120)
		{
			mReqLF = forwardVector + rotationVector;
			mReqRF = forwardVector - rotationVector;
			mReqLB = forwardVector + rotationVector;
			mReqRB = forwardVector - rotationVector;
		}
		else{
			mReqLF = forwardVector + rotationVector + horizontalVector;
			mReqRF = forwardVector - rotationVector - horizontalVector;
			mReqLB = forwardVector + rotationVector - horizontalVector;
			mReqRB = forwardVector - rotationVector + horizontalVector;
		}
		if(mReqLF != 0)
			motor[dLeftF] = trueSpeed(clamp(mReqLF));
		else
			motor[dLeftF] = 0;

		if(mReqRF != 0)
			motor[dRightF] = trueSpeed(clamp(mReqRF));
		else
			motor[dRightF] = 0;

		if(mReqLB != 0)
			motor[dLeftB] = trueSpeed(clamp(mReqLB));
		else
			motor[dLeftB] = 0;

		if(mReqRB != 0)
			motor[dRightB] = trueSpeed(clamp(mReqRB));
		else
			motor[dRightB] = 0;


		//if(abs(mReqLF) > DEADZONE)
		//	motor[dLeftF] = trueSpeed(clamp(mReqLF));
		//else
		//	motor[dLeftF] = 0;

		//if(abs(mReqRF) > DEADZONE)
		//	motor[dRightF] = trueSpeed(clamp(mReqRF));
		//else
		//	motor[dRightF] = 0;

		//if(abs(mReqLB) > DEADZONE)
		//	motor[dLeftB] = trueSpeed(clamp(mReqLB));
		//else
		//	motor[dLeftB] = 0;

		//if(abs(mReqRB) > DEADZONE)
		//	motor[dRightB] = trueSpeed(clamp(mReqRB));
		//else
		//	motor[dRightB] = 0;

		if(armUp==1)
		{
			armMotors=120;
		}

		else if((armDown==1))
		{
			armMotors=-120;
		}
		else
		{
			armMotors=0;
		}

		status=encoderLChange-SensorValue(armEncoderL);
		if (status>=0)
			signtemp=1;
		else
			signtemp=-1;
		/*
		if (signtemp>=sign)
		{
		while(SensorValue(potL)<3000)
		{
		motor[clawL]=-127;
		motor[clawR]=-127;
		}
		}*/
		sign=signtemp;
		/*
		if (SensorValue(armEncoderL)>initEncoderL && armDown==1)
		{
		motor[armL1]=0;
		motor[armL2]=0;
		motor[armR1]=0;
		motor[armR2]=0;
		}
		if(SensorValue(potL)<1150 && closeClaw==1)
		{
		motor[clawL]=0;
		motor[clawR]=0;
		}*/
		//}if(SensorValue(potL)>3350)
		//{
		//	motor[clawL]=50;
		//	motor[clawR]=50;
		//}
		clawValue = openClaw + closeClaw;
		motor[clawL] = clawValue;
		motor[clawR] = clawValue;
		//	if (SensorValue(armEncoderL)-initEncoderL<-200 && SensorValue(armEncoderL)-initEncoderL>-500 && SensorValue(potL)<3000)
		//	{
		//	motor[clawL]=-127;
		//	motor[clawR]=-127;
		//WAIT UNTIL OPEN
		//}
		//else
		//{

		//}
		//Set Motors
		reqArm(armMotors);

		//Displays Battery Levels to VEX Remote Screen
		powerExpanderBatteryV = SensorValue[in1]/.28;
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0,0);
		displayNextLCDString("C Bat:");
		displayNextLCDNumber(nAvgBatteryLevel);
		displayLCDPos(1,0);
		displayNextLCDString("P.E Bat:");
		displayNextLCDNumber(powerExpanderBatteryV);


		if(vexRT[Btn7UXmtr2] == 1)
		{
			startTask(OpenClaw);
		}


		datalogDataGroupStart();
		datalogAddValue(0, armMotors);
		datalogAddValue(1, clawValue);

		datalogAddValue(2, mReqLF);
		datalogAddValue(3, mReqRF);
		datalogAddValue(4, mReqLB);
		datalogAddValue(5, mReqRB);
		datalogDataGroupEnd();

		wait1Msec(LOOPSPEED);
	}
}

task usercontrol()
{
	startTask(control);
	startTask(armSlewControl);
}
