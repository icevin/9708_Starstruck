#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  armButton,      sensorTouCh)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           clawL,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           dLeftF,        tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port3,           dLeftB,        tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           armL1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armL2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armR1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armR2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           dRightF,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           dRightB,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          clawR,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// to turn left, motors are negative
//to turn right, motors are positive


/* NOTES

Potentiometer key:
Closed: ~3900
180 Degrees: ~2660
45 degrees (facing towards stars but not closed): ~1700
Fully closed: ~1000, 1100



*/



#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#define LOOPSPEED 50 //Time between user control loops in milliseconds - time alloted to other tasks while usercontrol is idle
#define DEADZONE 30 //Deadzone for joystick control
#define m_clawL 1
#define m_dLeftF 2
#define m_dLeftB 3
#define m_armL1 4
#define m_armL2 5
#define m_armR1 6
#define m_armR2 7
#define m_dRightF 8
#define m_dRightB 9
#define m_clawR 10


//TICKS PER REVOLUTION (ENCODER)
#define TURBOM          261.333
#define SPEEDM          392
#define TORQUM          627.2
#define QUAD          360.0

#define joy_left_vertical "Ch3Xmtr2"
#define joy_left_horizontal "Ch4Xmtr2"
#define joy_right_vertical "Ch2Xmtr2"
#define joy_right_horizontal "Ch1Xmtr2"

#define ROTATION_REDUCTION 0.75

#define PID_MAX 120
#define PID_MIN -120
#define PID_INTEGRAL_LIMIT 40
#define PID_POLL_RATE 100 //Milliseconds between PID controller updates

#define CLAW_FULL_CLOSED 1100
#define CLAW_HALF_CLOSED 1700
#define CLAW_180 2660
#define CLAW-STOWED 3800

//GLOBAL VARIABLES
float powerExpanderBatteryV;
//Control variables
int overFence, armC, armUp,armDown, rotateRight, rotateLeft, clawC,musicCtrl, openSlow, openFast, closeSlow, closeFast, direction=1, ChangeControl;
int armMotors;
unsigned int beat = 0;

#include "Vex_Competition_Includes.c"

//#include "music.h"


#include "StarstruckIncludes.h"
#include "motor.c"





void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.

	bStopTasksBetweenModes = true;
}

void halfOpenClaw()
{
	while(SensorValue(pot) < 2500 || SensorValue(pot) > 2800)
	{
		if(SensorValue(pot) < 2500)
		{
			motor[clawL] = -50;
			motor[clawR] = -50;
			wait1Msec(50);
		}
		if(SensorValue(pot) > 2800)
		{
			motor[clawL] = 50;
			motor[clawR] = 50;
			wait1Msec(50);
		}
	}
	wait1Msec(200);

	while(SensorValue(pot) < 2500 || SensorValue(pot) > 2800)
	{
		if(SensorValue(pot) < 2500)
		{
			motor[clawL] = -50;
			motor[clawR] = -50;
			wait1Msec(50);
		}
		if(SensorValue(pot) > 2800)
		{
			motor[clawL] = 50;
			motor[clawR] = 50;
			wait1Msec(50);
		}
	}
		motor[clawL] = 0;
		motor[clawR] = 0;
}

/*
while(SensorValue(pot)<2660)
{
motorclawL=-50;
wait1MSec(50);
if (Sensor
}
*/

void armRotationUser(int r)
{
	int counter=0;
	while(SensorValue(armEncoder) < r-24 || SensorValue(armEncoder) > r+24)
	{

		if(SensorValue(armEncoder) < r-24)
		{
			motor[armL1] = -50;
			motor[armL2] = -50;
			motor[armR1] = -50;
			motor[armR2] = -50;
			wait1Msec(50);
		}
		else if(SensorValue(armEncoder) > r+24)
		{
			motor[armL1] = 50;
			motor[armL2] = 50;
			motor[armR1] = 50;
			motor[armR2] = 50;

			wait1Msec(50);
		}
		if (counter>=r-40)
		{
			motor[clawR] = 20;
			motor[clawL]=20;
			wait1Msec(50);
		}
		counter+=1;

	}
}

void armRotation(int r)
{
	int counter=0;
	while(SensorValue(armEncoder) < r-24 || SensorValue(armEncoder) > r+24)
	{

		if(SensorValue(armEncoder) < r-24)
		{
			motor[armL1] = -50;
			motor[armL2] = -50;
			motor[armR1] = -50;
			motor[armR2] = -50;
			wait1Msec(500);
		}

		if(SensorValue(armEncoder) > r+24)
		{
			motor[armL1] = 50;
			motor[armL2] = 50;
			motor[armR1] = 50;
			motor[armR2] = 50;

			wait1Msec(500);
		}
		counter+=1;

	}
}

void auton1() {


	motor[clawR] = 70;
	motor[clawL]= 70;
	wait1Msec(1500);
	motor[clawR] = 0;
	motor[clawL] = 0;

	motor[armL1] = 100;
	motor[armL2] = 100;
	motor[armR1] = 100;
	motor[armR2] = 100;
	wait1Msec(2000);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;

	motor[dLeftB] = 70;
	motor[dRightB] = 70;
	motor[dLeftF] = 70;
	motor[dRightF] = 70;
	wait1Msec(1700);
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;

	motor[dLeftB] = -50;
	wait1Msec(200);
	motor[dRightB] = 50;
	wait1Msec(200);
	motor[dLeftF] = 50;
	wait1Msec(200);
	motor[dRightF] = 50;
	wait1Msec(5000);
	halfOpenClaw();
	armRotation(-256);

	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0;
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
}
/*
void auton2() {

motor[dLeftB] = 70;
motor[dRightB] = 70;
motor[dLeftF] = 70;
motor[dRightF] = 70;
wait1Msec(3000);
motor[dLeftB] = 0;
motor[dRightB] = 0;
motor[dLeftF] = 0;
motor[dRightF] = 0;
}
*/



void auton3(){
	/*
	//halfOpenClaw();
	motor[clawL] = 0;
	motor[clawR] = 0;
	armRotation(-256);

	motor[dLeftB] = -50;
	motor[dRightB] = 50;
	motor[dLeftF] = 50;
	motor[dRightF] = -50;
	wait1Msec(2500);



	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;

	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;

	*/
	while(SensorValue(pot) < 2500 || SensorValue(pot) > 2800)
	{
		if(SensorValue(pot) < 2500)
		{
			motor[clawL] = -50;
			motor[clawR] = -50;
			wait1Msec(50);
		}
		if(SensorValue(pot) > 2800)
		{
			motor[clawL] = 50;
			motor[clawR] = 50;
			wait1Msec(50);
		}
	}
	wait1Msec(200);

	while(SensorValue(pot) < 2500 || SensorValue(pot) > 2800)
	{
		if(SensorValue(pot) < 2500)
		{
			motor[clawL] = -50;
			motor[clawR] = -50;
			wait1Msec(50);
		}
		if(SensorValue(pot) > 2800)
		{
			motor[clawL] = 50;
			motor[clawR] = 50;
			wait1Msec(50);
		}
	}
	motor[clawL] = 0;
	motor[clawR] = 0;


	motor[dLeftB] = 80;
	motor[dRightB] = -80;
	motor[dLeftF] = 80;
	motor[dRightF] = -80;
	wait1Msec(2000);


	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	motor[dLeftF] = 0;
	motor[dRightF] = 0;

}


int armOpenPoint = -105;

void kevAuton() {
	halfOpenClaw();
	motor[dLeftF] = 75;
	motor[dRightF] = 120;
	motor[dLeftB] = 120;
	motor[dRightB] = 75;
	wait1Msec(1500);
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;
	//close claw function

	motor[clawL] = 90;
	motor[clawL] = 90;
	wait1Msec(1500);
	motor[clawL] = 50;
	motor[clawR] = 50;

	motor[dLeftF] = -50;
	motor[dRightF] = 90;
	motor[dLeftB] = -90;
	motor[dRightB] = 50;
	wait1Msec(1000);
	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;

	motor[dLeftF] = -90;
	motor[dRightF] = -90;
	motor[dLeftB] = -90;
	motor[dRightB] = -90;
	wait1Msec(1000);

	motor[dLeftF] = 0;
	motor[dRightF] = 0;
	motor[dLeftB] = 0;
	motor[dRightB] = 0;

	motor[armL1] = 100;
	motor[armL2] = 100;
	motor[armR1] = 100;
	motor[armR2] = 100;
	wait1Msec(1200);
	motor[clawL] = -90;
	motor[clawR] = -90;
	wait1Msec(300);
	motor[armL1] = 0;
	motor[armL2] = 0;
	motor[armR1] = 0;
	motor[armR2] = 0;
	motor[clawL] = 0;
	motor[clawR] = 0

}

task autonomous()
{
	kevAuton();


}


int forwardVector, horizontalVector, rotationVector;
task nonMusic() {
	nSchedulePriority = 10;
	//Math variables

	int mReqLF, mReqRF, mReqLB, mReqRB, clawValue;
	while(true){

		//int joyLV = vexRT[Ch3Xmtr2];
		//int joyLH = vexRT[Ch4Xmtr2];
		//int joyRV = vexRT[Ch2Xmtr2];
		//int joyRH = vexRT[Ch1Xmtr2];

		armC = vexRT[Ch2Xmtr2];
		openSlow = vexRT[Btn6UXmtr2] * 120;
		closeSlow = vexRT[Btn6DXmtr2] * -120;
		//		openFast = vexRT[Btn5U] * 120;
		//		closeFast = vexRT[Btn5D] * -120;
		clawC = vexRT[Ch1Xmtr2];
		armUp = vexRT[Btn5UXmtr2];
		armDown = vexRT[Btn5DXmtr2];
		ChangeControl = vexRT(Btn7LXmtr2);
		//overFence = vexRT(Btn8LXmtr2);
		//rotateRight = vexRT[Btn5U];
		//rotateLeft = vexRT[Btn5D];

		//musicCtrl = vexRT[Btn7UXmtr2];

		if(ChangeControl==1)
		{
			direction*=-1;
			wait1Msec(200);
		}
		if (overFence==1)
		{
			//armRotationUser(-180);
		}


		forwardVector = vexRT[Ch3Xmtr2];
		horizontalVector = vexRT[Ch4Xmtr2];
		rotationVector = vexRT[Ch1Xmtr2] * 0.5;

		mReqLF = forwardVector + rotationVector + horizontalVector;
		mReqRF = forwardVector - rotationVector - horizontalVector;
		mReqLB = forwardVector + rotationVector - horizontalVector;
		mReqRB = forwardVector - rotationVector + horizontalVector;

		if(abs(mReqLF) > DEADZONE)
			motor[dLeftF] = mReqLF;
		else
			motor[dLeftF] = 0;

		if(abs(mReqRF) > DEADZONE)
			motor[dRightF] = mReqRF;
		else
			motor[dRightF] = 0;

		if(abs(mReqLB) > DEADZONE)
			motor[dLeftB] = mReqLB;
		else
			motor[dLeftB] = 0;

		if(abs(mReqRB) > DEADZONE)
			motor[dRightB] = mReqRB;
		else
			motor[dRightB] = 0;



		/*
		if(ChangeControl==1)
		{
		direction*=-1;
		wait1Msec(200);
		}
		mReqD1 = (vexRT[Ch3Xmtr2] + vexRT[Ch1Xmtr2] + vexRT[Ch4Xmtr2]);
		mReqD2 = (vexRT[Ch3Xmtr2] - vexRT[Ch1Xmtr2] - vexRT[Ch4Xmtr2]);
		mReqD3 = (vexRT[Ch3Xmtr2] + vexRT[Ch1Xmtr2] - vexRT[Ch4Xmtr2]);
		mReqD4 = (vexRT[Ch3Xmtr2] - vexRT[Ch1Xmtr2] + vexRT[Ch4Xmtr2]);

		if(abs(mReqD1) > DEADZONE)
		motor[dLeftF] = mReqD1 * direction;
		else
		motor[dLeftF] = 0;

		if(abs(mReqD2) > DEADZONE)
		motor[dRightF] = mReqD2 * direction;
		else
		motor[dRightF] = 0;

		if(abs(mReqD3) > DEADZONE)
		motor[dLeftB] = mReqD3 * direction ;
		else
		motor[dLeftB] = 0;

		if(abs(mReqD4) > DEADZONE)
		motor[dRightB] = mReqD4 * direction;
		else
		motor[dRightB] = 0;
		*/
		if(SensorValue(armButton) == 1) {
			SensorValue(armEncoder) = 0;
		}
		//	if((abs(armC) > DEADZONE)&& (SensorValue(armButton) == 0 || armC > 0)) {
		//	armMotors =armC;
		//} else {
		//	armMotors = 0;
		//}

		if(armUp==1)
		{
			armMotors=120;
		}

		else if((armDown==1))
		{
			armMotors=-120;
		}
		else
		{
			armMotors=0;
		}



		clawValue = openSlow + closeSlow + openFast + closeFast;
		motor[clawL] = clawValue;
		motor[clawR] = clawValue;

		/*
		if(vexRT[Btn6UXmtr2] == 1) {
		clawState = 1;
		} else if(vexRT[Btn6DXmtr2] == 1) {
		clawState = -1;
		} else {
		clawState = 0;
		}

		if(clawState == 1) {
		clawReq = CLAW_FULL_CLOSED;
		} else if(clawState == -1) {
		clawReq = CLAW_180;
		} else if(clawState == 0) {
		clawReq = SensorValue(pot);
		} */




		//Set Motors
		reqArm(armMotors);
		/*
		motor[armL1] = armMotors;
		motor[armL2] = armMotors;
		motor[armR1] = armMotors;
		motor[armR2] = armMotors;
		*/



		//Displays Battery Levels to VEX Remote Screen
		powerExpanderBatteryV = SensorValue[in1]/.28;
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0,0);
		displayNextLCDString("C Bat:");
		displayNextLCDNumber(nAvgBatteryLevel);
		displayLCDPos(1,0);
		displayNextLCDString("P.E Bat:");
		displayNextLCDNumber(powerExpanderBatteryV);

		//if(vexRT[Btn8UXmtr2] == 1) {
		//	auton1();
		//}
		/*
		if(vexRT[Btn8DXmtr2] == 1) {
		auton2();
		}
		*/
		if(vexRT[Btn7UXmtr2] == 1)
		{
			halfOpenClaw();
		}


		datalogDataGroupStart();
		datalogAddValue(0, armMotors);
		datalogAddValue(1, clawValue);

		datalogAddValue(2, mReqLF);
		datalogAddValue(3, mReqRF);
		datalogAddValue(4, mReqLB);
		datalogAddValue(5, mReqRB);
		datalogDataGroupEnd();

		wait1Msec(LOOPSPEED);
	}
}



task usercontrol()
{
	//startTask(music);
	startTask(nonMusic);
	startTask(armSlewControl);
}
